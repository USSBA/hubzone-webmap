//= require hzmap
//= require ../helpers/sinon-1.17.6
//= require ../helpers/hz-jasmine
/* jshint unused: false */
/* jshint undef: false */

describe ('Testing wms operations', function() {
  beforeEach(function(){
    google = HZSpecHelper.google;
    HZApp.map = new google.maps.Map();
    HZApp.WMSUtils.checkForLayerStyles();
    layer  = 'qct_brac';
  });

  afterEach(function(){
    HZApp.map = {};
    HZSpecHelper.resetOverlays();
  });

  it("should get bbox", function() {
    var mapBounds = HZApp.map.getBounds();
    spyOn(mapBounds, 'getNorthEast').and.callThrough();
    spyOn(mapBounds, 'getSouthWest').and.callThrough();

    expect(HZApp.WMSUtils.getBbox(mapBounds)).toEqual("-98.35693359375,34.99419475828389,-96.64306640625,36.00264017338637");
    expect(mapBounds.getNorthEast.calls.count()).toEqual(2);
    expect(mapBounds.getSouthWest.calls.count()).toEqual(2);
  });

  it("should return correct imageBounds object", function(){
    spyOn(HZApp.WMSUtils, 'createGoogleLatLngBounds');
    var coordinates = HZSpecHelper.coordinates;
    var bboxStr = [coordinates.west, coordinates.south, coordinates.east, coordinates.north].join(',');

    var imageBounds = HZApp.WMSUtils.getImageBounds(bboxStr);
    expect(imageBounds).not.toBe(null);
    expect(HZApp.WMSUtils.createGoogleLatLngBounds).toHaveBeenCalled();
  });

  it("should run google latlng methods", function(){
    var coordinates = HZSpecHelper.coordinates;
    spyOn(google.maps, 'LatLngBounds');
    spyOn(google.maps, 'LatLng');

    HZApp.WMSUtils.createGoogleLatLngBounds(coordinates.west, coordinates.south, coordinates.east, coordinates.north);
    expect(google.maps.LatLngBounds.calls.count()).toEqual(1);
    expect(google.maps.LatLng.calls.count()).toEqual(2);
  });

  it("should build the correct URL", function() {
    var mapBounds = HZApp.map.getBounds();
    var bbox = HZApp.WMSUtils.getBbox(mapBounds);
    HZApp.WMSUtils.checkForLayerStyles();

    var sldXMLStyle = HZApp.Layers.LayerDefs.hzWMSOverlays[layer].sldXMLStyle;
    var url = HZApp.WMSUtils.buildWMSUrl({
      layer: layer,
      bbox: bbox,
      sldXMLStyle: sldXMLStyle
    });
    /* jshint ignore:start */
    var urlExpect = "<%= MAP_CONFIG[:geom_wms_settings][:url_root] %>";
    urlExpect += "&REQUEST=GetMap";
    urlExpect += "&SERVICE=WMS";
    urlExpect += "&VERSION=1.1.0";
    urlExpect += "&LAYERS=" + "<%= MAP_CONFIG[:geom_wms_settings][:workspace] %>:" + layer;
    urlExpect += "&FORMAT=image/png" ;
    urlExpect += "&TRANSPARENT=TRUE";
    urlExpect += "&SRS=EPSG:4326";
    urlExpect += "&BBOX=" + bbox;
    urlExpect += "&WIDTH=0"; // there is no map, so it will return a map with size 0
    urlExpect += "&HEIGHT=0";
    urlExpect += ('&SLD_BODY=' + encodeURIComponent(sldXMLStyle));
    /* jshint ignore:end */
    expect(url).toEqual(urlExpect);
  });

  it("should call the wms map layer stack", function(){
    spyOn(HZApp.WMSUtils, 'getBbox');
    spyOn(HZApp.WMSUtils, 'getImageBounds');
    spyOn(HZApp.WMSUtils, 'buildWMSUrl');
    spyOn(HZApp.WMSUtils, 'updateLayerWMSOverlay');
    spyOn(google.maps, 'GroundOverlay');

    HZApp.WMSUtils.fetchNewWMS({
      mapScope: HZApp.map,
      layer: layer
    });

    expect(HZApp.WMSUtils.getBbox.calls.count()).toEqual(1);
    expect(HZApp.WMSUtils.getImageBounds.calls.count()).toEqual(1);
    expect(HZApp.WMSUtils.buildWMSUrl.calls.count()).toEqual(1);
    expect(HZApp.WMSUtils.updateLayerWMSOverlay.calls.count()).toEqual(1);
    expect(google.maps.GroundOverlay.calls.count()).toEqual(1);
  });

  it("should fetchNewWMS for as many layers as are defined", function(){
    spyOn(HZApp.WMSUtils, 'fetchNewWMS');
    HZApp.WMSUtils.updateIdleMap(HZApp.map);
    var layerLength = Object.keys(HZApp.Layers.LayerDefs.hzWMSOverlays).length;
    expect(HZApp.WMSUtils.fetchNewWMS.calls.count()).toEqual(layerLength);
  });

  it("should update the map WMS layer, adding a new overlay where there was none before", function(){
    var mockOverlay = new HZSpecHelper.NewOverlay('new');
    spyOn(mockOverlay, 'setMap');
    spyOn(mockOverlay, 'addListener');
    HZApp.Layers.LayerDefs.hzWMSOverlays[layer].overlay.push(mockOverlay);

    HZApp.WMSUtils.updateLayerWMSOverlay({
      layer: layer,
      mapScope: HZApp.map
    });

    expect(mockOverlay.setMap.calls.count()).toEqual(1);
    expect(mockOverlay.addListener.calls.count()).toEqual(2);
  });

  it("should update the map WMS layer, replacing the old overlay with a new one", function(){

    var mockOverlayOld = new HZSpecHelper.NewOverlay('old');
    var mockOverlayNew = new HZSpecHelper.NewOverlay('new');

    spyOn(mockOverlayOld, 'setMap');
    spyOn(mockOverlayNew, 'setMap');
    spyOn(mockOverlayNew, 'addListener');
    HZApp.Layers.LayerDefs.hzWMSOverlays[layer].overlay.push(mockOverlayOld);
    HZApp.Layers.LayerDefs.hzWMSOverlays[layer].overlay.push(mockOverlayNew);

    HZApp.WMSUtils.updateLayerWMSOverlay({
      layer: layer,
      mapScope: HZApp.map
    });

    expect(mockOverlayNew.setMap.calls.count()).toEqual(1);
    expect(mockOverlayNew.addListener.calls.count()).toEqual(2);
  });

  it("should handle an empty WMS update call", function(){
    HZSpecHelper.resetOverlays();
    var updateState = HZApp.WMSUtils.updateLayerWMSOverlay({
      layer: layer,
      mapScope: HZApp.map
    });
    expect(updateState).toBe(null);
  });
});
