//defining global variables for hubzone map controllers
var map = {}; //the map object
var wmsGroundOverlay = {
  indian_lands: [],
  qnmc: [],
  qct: [],
  brac: []
};

//create the map on load, when idle, jump to updateMap to get features
/* exported initMap */
function initMap() {

  map = new google.maps.Map(document.getElementById('map'), {
    center: {lat: 35.5, lng: -97.5},
    zoom: 9,
    zoomControl: true,
    mapTypeControlOptions: {
      mapTypeIds: ['hz_map', 'roadmap', 'satellite' ],
      style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
    }
  });

  //adds in the hz style into the basemap picker
  var hzStyledMap = new google.maps.StyledMapType(hzBaseMapStyle, {name: 'Default'});
  map.mapTypes.set('hz_map', hzStyledMap);
  map.setMapTypeId('hz_map');

  //adds the map legend
  map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(document.getElementById('legend'));

  // adds listener that triggers whenever the map is idle to update with new features.
  google.maps.event.addListener(map, 'tilesloaded', updateIdleMap);

  map.addListener('click', catchMapClick);

  //adds autocomplete
  var searchInput = document.getElementById('search-field-small');
  var options = {
    types: ['geocode']
  };
  /* jshint unused: false */
  var autocomplete = new google.maps.places.Autocomplete(searchInput, options);

  //returns the map
  return map;
}

function updateIdleMap(){
  mapScope = this;
  //for each layer defined in the wmsGroundOverlay object call the fetchNewWMS function
  // update the WMS call for that layer
  Object.keys(wmsGroundOverlay).map(function(layer){
    fetchNewWMS({
      mapScope: mapScope,
      layer: layer
    });
  });
}

function fetchNewWMS(options){
  //get the map extents and build URL
  var bbox = getBbox(options.mapScope);
  var imageBounds = getImageBounds(bbox);
  var layer = options.layer;

  var url = buildWMSUrl({
    layer: layer,
    bbox: bbox
  });

  //push a new groundOverlay into the wmsGroundOverlay array container
  wmsGroundOverlay[layer].push(new google.maps.GroundOverlay(
      url,
      imageBounds
  ));

  //update WMS layers, removing old and adding new to the map
  updateLayerWMSOverlay({
    layer: layer, 
    mapScope: options.mapScope
  });
}

function getBbox(mapScope) {
  //get the bounding box of the current map and parse as a string
  var mapBounds = mapScope.getBounds();
  var NELat = mapBounds.getNorthEast().lat();
  var NELng = mapBounds.getNorthEast().lng();
  var SWLat = mapBounds.getSouthWest().lat();
  var SWLng = mapBounds.getSouthWest().lng();
  return [SWLng, SWLat, NELng, NELat].join(',');
}

function getImageBounds(bbox){
  var bboxArr = bbox.split(',');
  var imageBounds = createGoogleLatLngBounds(
                      parseFloat(bboxArr[0]),
                      parseFloat(bboxArr[1]),
                      parseFloat(bboxArr[2]),
                      parseFloat(bboxArr[3])
  );
  return imageBounds;
}

//commented out for now since switching do WMS does not immeaditely require
// var geomWFSSettings = JSON.parse('<%= MAP_CONFIG[:geomWFSSettings].to_json %>');
// var currentZoom = mapScope.getZoom();
// function getTableBasedOnZoomLevel(currentZoom){
//   var table = geomWFSSettings.tableHighRes;
//   if (currentZoom >= 12) {
//     table = geomWFSSettings.tableHighRes;
//   } else if (currentZoom >= 10){
//     table = geomWFSSettings.tableLowRes;
//   } else if (currentZoom >= 6){
//     table = geomWFSSettings.tableLowerRes;
//   } else {
//     table = geomWFSSettings.tableLowestRes;
//   }
//   return table;
// }

//helper for building google lat lng bounds objectfrom a set of lat long coordinates
//coordinate order corresponds to min X, min Y, max X, max Y
function createGoogleLatLngBounds(SWLng, SWLat, NELng, NELat){
  return new google.maps.LatLngBounds(
      new google.maps.LatLng(SWLat, SWLng),
      new google.maps.LatLng(NELat, NELng)
    );
}

// builds out the custom wms url
function buildWMSUrl(options){
  var url = "http://localhost:8080/geoserver/hubzone-test/wms?service=WMS";
  url += "&REQUEST=GetMap"; 
  url += "&SERVICE=WMS";    
  url += "&VERSION=1.1.0";    
  url += "&LAYERS=" + "hubzone-test:" + options.layer  ; 
  url += "&FORMAT=image/png" ; 
  url += "&TRANSPARENT=TRUE";
  url += "&SRS=EPSG:4326";      
  url += "&BBOX=" + options.bbox;
  url += "&WIDTH=" + parseInt($('#map').width()*1); //double the resolution for better screens, but make sure its int        
  url += "&HEIGHT=" + parseInt($('#map').height()*1); //double the resolution for better screens, but make sure its int
  url += ('&SLD_BODY=' + constructSLDXML(hzMapLayerStyle[options.layer]));
  return url;             
}

//helper function for updating a single layer's WMS overlay
function updateLayerWMSOverlay(options){
  var layer = options.layer;
  if (wmsGroundOverlay[layer].length === 1){
    wmsGroundOverlay[layer][0].setMap(options.mapScope);
  } else if (wmsGroundOverlay[layer].length > 1){ //assume last is newest and any other have to go
    var tmpLayer = wmsGroundOverlay[layer][wmsGroundOverlay[layer].length-1];
    for (var i = 0; i < wmsGroundOverlay[layer].length-1; i++) {
      wmsGroundOverlay[layer][i].setMap(null);
    }
    wmsGroundOverlay[layer] = [];
    wmsGroundOverlay[layer].push(tmpLayer);
    wmsGroundOverlay[layer][0].setMap(options.mapScope);
  } else { //
    // console.warn('no WMS found in layer');
    return null;
  }
  wmsGroundOverlay[layer][0].addListener('click', catchMapClick);  
}

// turn latlng object into url
function catchMapClick(clickEvent){
  var clicklng = clickEvent.latLng.lng();
  var clicklat = clickEvent.latLng.lat();
  var url = "/search?latlng=" + clicklat + ',' + clicklng;
  $.ajax({
    url: url
  });
  return url;
}

//jump to location on the map based on the geocode viewport object
/* exported jumpToLocation */
function jumpToLocation(geocodeLocation){
  if (geocodeLocation.viewport){
    var newBounds = createGoogleLatLngBounds(
                      geocodeLocation.viewport.southwest.lng,
                      geocodeLocation.viewport.southwest.lat,
                      geocodeLocation.viewport.northeast.lng,
                      geocodeLocation.viewport.northeast.lat
      );
    map.fitBounds(newBounds);
  }
}

// helperf for building out the style object
function constructSLDXML(options){
  return encodeURIComponent('<?xml version="1.0" encoding="UTF-8"?>' +
          '<StyledLayerDescriptor xmlns="http://www.opengis.net/sld" xmlns:ogc="http://www.opengis.net/ogc" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0.0" xsi:schemaLocation="http://www.opengis.net/sld StyledLayerDescriptor.xsd">' + 
          '<NamedLayer>' +
          '<Name>hubzone-test:' + options.layer + '</Name>' +
          '<UserStyle>' +
          '<FeatureTypeStyle>' +
          (options.styleExpiring ? styleWithExpiration(options) : styleWithoutExpiration(options) ) + 
          '</FeatureTypeStyle>' +
          '</UserStyle>' +
          '</NamedLayer>' +
          '</StyledLayerDescriptor>');
}

function styleWithExpiration(options){
return ('<Rule>' + 
        '<Name>not expiring</Name>' + 
        '<ogc:Filter>' + 
        '<ogc:PropertyIsEqualTo>' + 
        '<ogc:Function name="isNull">' + 
        '<ogc:PropertyName>stop</ogc:PropertyName>' + 
        '</ogc:Function>' + 
        '<ogc:Literal>true</ogc:Literal>' + 
        '</ogc:PropertyIsEqualTo>' + 
        '</ogc:Filter>' + 
        '<PolygonSymbolizer>' + 
        '<Fill>' + 
        '<CssParameter name="fill">' + options.fillColor + '</CssParameter>' + 
        '<CssParameter name="fill-opacity">' + options.fillOpacity + '</CssParameter>' + 
        '</Fill>' + 
        '<Stroke>' + 
        '<CssParameter name="stroke">' + options.strokeColor + '</CssParameter>' + 
        '<CssParameter name="stroke-width">' + options.strokeWidth + '</CssParameter>' + 
        '</Stroke>' + 
        '</PolygonSymbolizer>' + 
        '</Rule>' + 
        '<Rule>' + 
        '<Name>expiring</Name>' + 
        '<ogc:Filter>' + 
        '<ogc:PropertyIsEqualTo>' + 
        '<ogc:Function name="isNull">' + 
        '<ogc:PropertyName>stop</ogc:PropertyName>' + 
        '</ogc:Function>' + 
        '<ogc:Literal>false</ogc:Literal>' + 
        '</ogc:PropertyIsEqualTo>' + 
        '</ogc:Filter>' + 
        '<PolygonSymbolizer>' + 
        '<Fill>' + 
        '<GraphicFill>' + 
        '<Graphic>' + 
        '<Mark>' + 
        '<WellKnownName>shape://backslash</WellKnownName>' + 
        '<Stroke>' + 
        '<CssParameter name="stroke">' + options.strokeColor + '</CssParameter>' + 
        '<CssParameter name="stroke-width">' + options.strokeWidth + '</CssParameter>' + 
        '</Stroke>' + 
        '</Mark>' + 
        '<Size>16</Size>' + 
        '</Graphic>' + 
        '</GraphicFill>' + 
        '</Fill>' + 
        '<Stroke>' + 
        '<CssParameter name="stroke">' + options.strokeColor + '</CssParameter>' + 
        '<CssParameter name="stroke-width">' + options.strokeWidth + '</CssParameter>' + 
        '</Stroke>' + 
        '</PolygonSymbolizer>' + 
        '</Rule>');
}

function styleWithoutExpiration(options){
  return ('<Rule>' + 
          '<Name>not expiring</Name>' + 
          '<PolygonSymbolizer>' + 
          '<Fill>' + 
          '<CssParameter name="fill">' + options.fillColor + '</CssParameter>' + 
          '<CssParameter name="fill-opacity">' + options.fillOpacity + '</CssParameter>' + 
          '</Fill>' + 
          '<Stroke>' + 
          '<CssParameter name="stroke">' + options.strokeColor + '</CssParameter>' + 
          '<CssParameter name="stroke-width">' + options.strokeWidth + '</CssParameter>' + 
          '</Stroke>' + 
          '</PolygonSymbolizer>' + 
          '</Rule>');
}

