//defining global variables for hubzone map controllers
var map = {}; //the map object

//create the map on load, when idle, jump to updateMap to get features
/* exported initMap */
function initMap() {

  map = new google.maps.Map(document.getElementById('map'), {
    center: {lat: 35.5, lng: -97.5},
    zoom: 9,
    zoomControl: true,
    zoomControlOptions: {
      position: google.maps.ControlPosition.RIGHT_BOTTOM
    },
    streetViewControlOptions: {
      position: google.maps.ControlPosition.RIGHT_BOTTOM
    },
    mapTypeControlOptions: {
      mapTypeIds: ['hz_map','roadmap', 'satellite' ],
      position: google.maps.ControlPosition.BOTTOM_CENTER
    }
  });

  //adds in the hz style into the basemap picker
  var hzStyledMap = new google.maps.StyledMapType(hzBaseMapStyle, {name: 'Default'});
  map.mapTypes.set('hz_map', hzStyledMap);
  map.setMapTypeId('hz_map');

  //adds the map legend
  map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(document.getElementById('legend'));

  // adds listener that triggers whenever the map is idle to update with new features.
  google.maps.event.addListener(map, 'idle', updateIdleMap);

  map.addListener('click', catchMapClick);

  //adds autocomplete
  var searchInput = document.getElementById('search-field-small');
  var options = {
    types: ['geocode']
  };
  /* jshint unused: false */
  var autocomplete = new google.maps.places.Autocomplete(searchInput, options);

  //returns the map
  return map;
}

function updateIdleMap(){
  var map = this;
  //for each layer defined in the hzWMSOverlays object call the fetchNewWMS function
  // update the WMS call for that layer
  Object.keys(hzWMSOverlays).map(function(layer){
    fetchNewWMS({
      mapScope: map,
      layer: layer
    });
  });
}

function fetchNewWMS(options){
  //get the map extents and build URL
  var bbox = getBbox(options.mapScope.getBounds());
  var imageBounds = getImageBounds(bbox);
  var layer = options.layer;

  var url = buildWMSUrl({
    layer: layer,
    bbox: bbox
  });

  //push a new groundOverlay into the hzWMSOverlays array container
  hzWMSOverlays[layer].overlay.push(new google.maps.GroundOverlay(
      url,
      imageBounds
  ));

  //update WMS layers, removing old and adding new to the map
  updateLayerWMSOverlay({
    layer: layer,
    mapScope: options.mapScope
  });
}

function getBbox(mapBounds) {
  //get the bounding box of the current map and parse as a string
  var NELat = mapBounds.getNorthEast().lat();
  var NELng = mapBounds.getNorthEast().lng();
  var SWLat = mapBounds.getSouthWest().lat();
  var SWLng = mapBounds.getSouthWest().lng();
  return [SWLng, SWLat, NELng, NELat].join(',');
}

function getImageBounds(bbox){
  var bboxArr = bbox.split(',');
  var imageBounds = createGoogleLatLngBounds(
                      parseFloat(bboxArr[0]),
                      parseFloat(bboxArr[1]),
                      parseFloat(bboxArr[2]),
                      parseFloat(bboxArr[3])
  );
  return imageBounds;
}

//commented out for now since switching do WMS does not immeaditely require
// var geomWFSSettings = JSON.parse('<%= MAP_CONFIG[:geomWFSSettings].to_json %>');
// var currentZoom = mapScope.getZoom();
// function getTableBasedOnZoomLevel(currentZoom){
//   var table = geomWFSSettings.tableHighRes;
//   if (currentZoom >= 12) {
//     table = geomWFSSettings.tableHighRes;
//   } else if (currentZoom >= 10){
//     table = geomWFSSettings.tableLowRes;
//   } else if (currentZoom >= 6){
//     table = geomWFSSettings.tableLowerRes;
//   } else {
//     table = geomWFSSettings.tableLowestRes;
//   }
//   return table;
// }

//helper for building google lat lng bounds objectfrom a set of lat long coordinates
//coordinate order corresponds to min X, min Y, max X, max Y
function createGoogleLatLngBounds(SWLng, SWLat, NELng, NELat){
  return new google.maps.LatLngBounds(
      new google.maps.LatLng(SWLat, SWLng),
      new google.maps.LatLng(NELat, NELng)
    );
}

// builds out the custom wms url
function buildWMSUrl(options){
  var url = "<%= MAP_CONFIG[:geom_wms_settings][:url_root] %>";
  url += "&REQUEST=GetMap";
  url += "&SERVICE=WMS";
  url += "&VERSION=1.1.0";
  url += "&LAYERS=" + "<%= MAP_CONFIG[:geom_wms_settings][:workspace] %>:" + options.layer;
  url += "&FORMAT=image/png" ;
  url += "&TRANSPARENT=TRUE";
  url += "&SRS=EPSG:4326";
  url += "&BBOX=" + options.bbox;
  url += "&WIDTH=" + parseInt($('#map').width()*2); //double the resolution for better screens, but make sure its int
  url += "&HEIGHT=" + parseInt($('#map').height()*2); //double the resolution for better screens, but make sure its int
  url += ('&SLD_BODY=' + constructSLDXML(options.layer));
  return url;
}

//helper function for updating a single layer's WMS overlay
function updateLayerWMSOverlay(options){
  var wmsLayer = hzWMSOverlays[options.layer].overlay;
  if (wmsLayer.length === 1){
    wmsLayer[0].setMap(options.mapScope);
  } else if (wmsLayer.length > 1){ //assume last is newest and any other have to go
    var tmpLayer = wmsLayer[wmsLayer.length-1];
    for (var i = 0; i < wmsLayer.length-1; i++) {
      wmsLayer[i].setMap(null);
    }
    hzWMSOverlays[options.layer].overlay = [];
    hzWMSOverlays[options.layer].overlay.push(tmpLayer);
    hzWMSOverlays[options.layer].overlay[0].setMap(options.mapScope);
  } else { //
    // console.warn('no WMS found in layer');
    return null;
  }
  hzWMSOverlays[options.layer].overlay[0].addListener('click', catchMapClick);
}

// turn latlng object into url
function catchMapClick(clickEvent){
  var clicklng = clickEvent.latLng.lng();
  var clicklat = clickEvent.latLng.lat();
  var date = parseDate(new Date());
  var locale = "<%= I18n.locale %>";
  // Log the click
  HZ.track( 'map', 'click', clicklat + ',' + clicklng );
  var url = "<%= search_path %>?latlng=" + clicklat + ',' + clicklng + '&query_date=' + date + '&locale=' + locale;
  $.ajax({
    url: url
  });
  return url;
}

//helper to parse a javascript date because, why?
function parseDate(date){
  var mm = date.getMonth() + 1;
  var dd = date.getDate();

  return [date.getFullYear(),
          (mm>9 ? '' : '0') + mm,
          (dd>9 ? '' : '0') + dd
         ].join('-');
}

//jump to location on the map based on the geocode viewport object
/* exported jumpToLocation */
function jumpToLocation(geocodeLocation){
  if (geocodeLocation.viewport){
    var newBounds = createGoogleLatLngBounds(
                      geocodeLocation.viewport.southwest.lng,
                      geocodeLocation.viewport.southwest.lat,
                      geocodeLocation.viewport.northeast.lng,
                      geocodeLocation.viewport.northeast.lat
      );
    map.fitBounds(newBounds);
  }
}
